 // 일단 promise를 제ㅐㄷ로 알고계시는지부터 확인을 좀 해보겟습니다
  (async () => 1)()
  //number
  // 아닌데요 ㅅㄱ
  // async함수는 기본적으로
  // Promise를 간편하게 다루기 위한 문법인데
  // async 함수에선 await을 쓸 수 있는 대신
  // 무조건 반환값이 Promise에 감싸져서 나옵니다
  // 그러므로 쟤는 number가 아니라 Promise<number>에요
  // 그리고 전에 제가 보내드린 링크 보면
  // Promise에 then이라는게 있는데요
  // promise가 resolve되면 뭘 할지 지정할수있는겁니다
  // resolve 되었다는게 이행하는게 끝났다는 건가요
  // 에러 없이 이행됐다는거죠 (에러발생하면 reject되므로)
  // 아니 한글 왜 안되냘ㅇ머;라ㅓ
  // resolve reject로 해서 아니 이미 쓰셧네 개빡치네
  // 음 정리하자면
  // 1. async 는 promise를 편하기 쓰기 위해 나온 것이다.
  // 2. 겉으로는 async await 써서 끝내는 것처럼 보이지만 
  // 3. 실질적으로는 promise로 묶여서 진행되는 것이다.?
  // 4. async는 비동기 -> 내용은 실행 되었지만 반환은 아직 안한 걸로 이해하면? 된?다?
  // 아니 잠만 비동기 의미 자체가 갑자기 헷갈리는데
  
  // 비동기 -> 특정 코드 연산이 끝날때까지 코드 멈추지 않고 다음 코드를 먼저 실행
  
  // 네
  // 결국은 promise임니다
  // async를 promise로 풀어서 이해하시면 더 쉽게 이해 가능할듯
  
  (async () => {
    console.log('asdf')
  })()
  
  console.log('qwer')
  
  // 결과는 어떻게 될까요
  // qwer , asdf
  // 틀렸습니다
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise#description
  // 좀 내리다보면 1 2 3 4 5 나오는데 3번 보실
  // The executor is called synchronously (as soon as the Promise is constructed) 
  // 뒤쪽은 필요없으므로 지우겟습니다 개빡치네
  // 동시에 부른다고 하는데 보니까 promise 가 생성 된 이후로 executor 가 동시 호출이라고 하네요
  // 
  // synchronously는 동시에가 아닌데요(여기서 쓰인 의미는) 동기임? 네 
  // 동기적으로 호출되므로
  // 위 코드의 결과는 asdf qwer입니다
  // 근데 이건 이런 코드만 있을때의 얘기고요
  // await같은게 들어가기 시작하면 얘기가 좀 달라지죠
  // await을 써서 setTimeout같은 비동기적인 작업을 하기 시작하면
  // setTimeout에 들어가는 결과는 더이상 동기적으로 얻을수가 없게 되겠죠
  // 자 그러면 async 는 promise 반환 용도고
  // await 는 promise가 끝날때까지 한조 대기중 하는거고(async 함수 내에서 <- 중요)
  // 저 영어 초보?ㄴ
  // 그러면 await async는 뗄수 없는 존재가 되는거고
    // 그러면 async 해서 return 한다고 하면
    // 어떻게 되는거죠? 그냥 비동기가 아니라 동기가 되는거임?
  // 네 그래서 설명하는 글들 보면 다 묶어서 설명하잖아요
  // await만 따로 설명하는 글은 없음
  // 동기적으로 실행하긴 하지만
  // Promise에 감싸져서 오겠죠
  // promise는 비동기 아님?
  // '비동기 작업을 수행할 수 있는 박스'
  // Promise가 동기적인 작업을 하는게 가능은 하다는거죠
  // 근데 거의 안 쓰일 뿐
  // 여튼 그래서
  // Promise 생성자의 콜백 내에서 동기적인 작업을 하면
  // 뭐 비동기적으로 기다릴 게 없으니까
  // 연산이 완료되는 즉시 resolve되고요(이 코드 아래쪽의 코드에서는 pending 상태를 볼 일이 없음)
  // 그러면 그냥 무조건 resolve돼있는 일종의 박스가 돼버리는거죠
  // 음
  // callback에서 동기적인 연산만 한다면요
  new Promise((resolve) => {
    const a = 1
    const b = 2
    resolve(a + b)
  })
  // Promise (resolved) 결과값: 3
  // 하지만 얜 여전히 Promise기 때문에
  // Promise라는 박스 안에 있는거죠
  // then을 쓰거나 async함수 내에서 await을 하든가 할 수 있겠죠
  // 네 promise를 나오지 않았다는 거죠?
  // 그러면 그러기 위해서는 then 이나 callback이나 무언가를 처리 해야 한다는 거고
  // 근데 저런 promise callback 이런게 무한 콜백 루픋가 되어 버리니 해결 방법으로 async await 나온거고
  // 콜백때문이라기보단
  // .then() 도배 때문이겠죠 아무래도
  // .then()의 콜백 안에 다른 promise의 .then() 쓰고 이러면 코드가 **해지니까
  // 그걸 막기위해서 async를
  const f = (대충 promise 반환하는 함수 1)
  const g = (대충 promise 반환하는 함수 2)
  
  f().then(result => {
    return g().then(result2 => {
      return [result, result2]
    })
  })
  (async () => {
    const result = await f()
    const result2 = await g()
    return [result, result2]
  })()
  // 간단하게 예시 2개 가능한가요
  // 깔금해 보이군요
  //  fetch
  // 네 근데 때로는 그냥 .then() 쓰는게 깔끔한 경우도 있는데요
  // 제가 생각하는 대표적인 경우는 단일 fetch입니다
  fetch('asdf')
    .then(res => res.json())
    .then(res => res.asdf)
  // 왜냐면
  // Promise는 flatMap을 수행하기 때문인데요
  // 간단히 말하자면
  
  // 네 여튼 그래서
  // 배열이 대부분의 연산을 설명하기 가장 쉽고 그래서 배열로 설명해봤는데요
  // 사실 Promise의 then이 Promise에 대한 flatMap입니다
  // 여기서
  // res.json()의 반환 타입을 잘 보면
  // Promise<any>인데요
  // 그러면 결론적으로 fetch의 반환 타입 역시 Promise<Response>므로
  // (별 생각 없이 봤을때는) fetch(...).then(res => res.json())의 타입은 Promise<Promise<any>>로 보입니다
  // 근데 얘의 타입은 여전히 Promise<any>에요
  // 왜냐면 then은 flatMap이기 때문에
  // Promise<Promise<any>>에서 중첩되는 Promise<>를 덜어내고
  // Promise<any>로 평평하게 만들기 때문입니다
  //ㅖ
  
  // 이해되심?굿
  
  // 여튼 이 Promise의 then이 flatMap이란 특성때문에
  // 이런 면에서 빛을 발하는데요
  // 위의 코드를 async/await으로 재작성해보면
  
  // (대충 async함수 안)
  const response = await fetch('asdf')
  const json = await response.json()
  json.asdf
  // 만약에 불필요한 변수(response) 없이 짜고싶다면
  
  const json = await (await fetch('asdf')).json()
  json.asdf
  // 겁나더럽죠
  // await에다 소괄호까지 써야해서
  // 코드가 겁나 난잡해짐니다
  // 저게 제가 짠 코드네요
  // 네 딱 님이짠코드죠
  
  // mdn에서도 저런 코드를 소개해주고 있고
  // 만약에 then을 쓴다면
  const asdf = await fetch('asdf')
    .then(res => res.json())
    .then(json => json.asdf)
  // 또는
  const json = await fetch('asdf')
    .then(res => res.json())
  json.asdf
  // (훨씬 간결)
  // 그러면 원래 코드로 돌아와서
  
  
  // 여튼 이거를 딱 보면 대충 함수같다는 느낌을 받을 수 있는데요
  // 이거를 자료구조에 적용해보면
  // 자료구조의 각 원소마다 어떤 변환을 적용시킨다
  // 라고 볼수가 있습니다
  // 대표적으로 Array#map()을 보면
  // 배열의 각 원소마다 변환을 적용시키죠
  // 그래서 이번에 할 작업중에 array.map(x => x + safd ) 뭐 이런 식으로 해야 한다?
  // 네 머 그래서 Promise를 보면
  // flatMap이라고 했는데
  // flat 아시나요 (단순히 영단어 말고)
  // 네 그건 압니다.
  // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
  // 어제 이미 그 쪼리핑한테
  // 맞아서 ㅇㅇ
  // 그럼 flatMap은 아시나요
  // flatMap이요 음 배열 리스트 평준화까진 알음
  // arr.flatMap(x => x+2) 이면 [0,1,2] => [2,3,4]? 그럼요
  // 함수를 합성할때 g(f(x))를 g . f로 나타내는건 아시죠
  // flatMap도 map과 flat을 합성한건데요
  // flat은
  [[1, 2, 3], [4, 5, 6], [7, 8, 9]].flat() // [1, 2, 3, 4, 5, 6, 7, 8, 9]
  // 입니다
  // 단어 뜻과 비슷하게 평평하게 만드는건데요
  // 이제 flatMap은 그러면
  // 변환을 수행한 뒤에 평평하게 만드는거겠죠
  // 얘가 은근 유용한데
  // 얘를 이용해서 배열의 .filter()도 구현할 수 있습니다
  function filter(array, callback) {
    return array.flatMap((item, ...args) => {
      if (callback(item, ...args)) return [item]
      else return []
    })
  }
  // 여기 이렇게 코드를 썼잖아요

  // 왜 배열에 감쌌을까요
  // 그리고 왜 밑에는 빈 배열을 반환할까요
  // 배열로 감싼 이유가 flatMap 의 특성상 배열로 반환을 하기 때문에 그런거 아닌가요
  //                                  ^^^^^^^^^^^^^^^^^^^^^ 이래야 하는 이유 = 을(를) 수행하기 때문
  // flat을 수행하기 때문
  // 이제 왜 flat을 수행하기때문에 저래야 하는지 아시겠나요
  // 그럽면 flatmap에 flat이 들어 있다? 라고 생각하면 되는 건가요?
  // flatMap = flat . map
  // 여튼 그래서
  // 
  
  // 좀 보기쉽게 하자면
  [1, 2, 3].flatMap((item, ...args) => {
    if (item < 2) return [item]
    else return []
  })
  // 이해 완료
  
 
  // 가 되겠네요
  // 아 언가의 개념설명 재밌네요  ㅠ

  // 이걸 flatMap으로 구현할 수 있다
  [1, 2, 3].filter(x => x < 2) -> 이게 map이다
  // 이걸 예로 들어보자면
  // 일차적으로 map만 수행했을때는
  [[1], [], []] // 가 되겠죠 (map 결과)
  // 일단 이렇게 되겠죠
  // 여기서 이제 flat이 활약하는데요
  // flat은 평평하게 만든다고 했었죠
  // 빈 배열은 평평하게 만들었을 때 갖고있는 원소가 없기 때문에 소멸됩니다
  [1] // 짜잔 (map 결과에다 flat 한 결과)
  // 이걸 더 이해하기 쉽게 나타내면
  [...[1], ...[], ...[]] // 이 되겠네요
  // 잠만 이해가 안되는데 
  //filter 에서 x<3 조건으로 하면 [1,2,3,4,5] 라는 조건 하에 진행 된다고 하면 [1,2] 이렇게 나오는게 아닌가요?
  // 네 근데 그거는 최종결과구요
  // flatMap의 합성을 잠깐 분리한뒤에 순차적으로 보자는거죠
  // 잠만 한번 더 감싸요?
  // 아 ㅇㅋ
  
  // 좀 더 근본적인 이유요
  // 
  // 여기서 [item]과 []이 뭘 의도한건지 아시겠나요
  
  
  // 네 그건 알음
  
  // key value 는 알죠
  // 이건 ㅊ++ map 많이 쓰니 압니다
  // 저거 자바 내용인게 있네
  // 값과 다른 값을 서로 대응한다 네 
  // ex?
  // 그 비유가 그 그그그 그냥 이해할께요
  // 
  
  // 그 뭐지 무엇을 말씀하시는지 모르겠어요 저 문법은 뭔지 아는데
  // 네 대충 이렇게 ㅣㅇ해하심 됨
  // Promise 생성자의 콜백도 기본적으로는 동기적이라는거죠
  // 근데 이제 비동기적 작업이 포함돼있으면 resolve나 reject될때까지 기다리면 되는거고
  // C 의 포인터 느낌이네
  // 그렇죠? 네 그렇죠?
  // ?ㅠ
  // 얘는 연달아서 쓸수가있고요(promise.then(...).then(...) 같이)
  //개빡치네
  // 이 식의 타입은 뭘까요
  
  // 근데 잠시만요
  // 어제 했던 질문 계속하겟습니다
  // fetch가 왜필요하죠 걍 <Image /> 쓰면 끝아닌가
  // 이미지가 동적인건가요
  // 정적이네 굳이 이미지가 따로 처리 하는게 없네 그러면 그 뭐지 이미지 한꺼번에 미리 로딩 시킬려면 비동기 작업만
  // 근데애초에 왜 한꺼번에 미리 로드해야하는거죠? LG 현직자 조언 땨ㅐ문에요  ㄱㅋ
  // 하면 되는 건가요 개빡치네 ?ㄴ 그분이 팀장이여서 조언 따를려고 고치는 건데요 저 일단 밥 묵고 옴 언가님도
  // 드시고 오시죠 
  // 저 이미 햇반 데워서 먹었는데요 ㅅㄱ 그럼 더 드세요 개빡치네 네 ?ㄷ
  // 자 그러면
  // 여기에서 
  //  이미지 http 불러와서 해야 하니 그랬는데요 이거 홈페이지로 가면 안될걸요 로컬이여서 가능하지(?)